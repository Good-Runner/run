# 7장 로봇 프로젝트

### 메도우필드 - 마을의 도로 배열을 도로의 목록을 각 지역마다 도달할 수 있는 정보를 알려주는 자료 구조로 변환

```javascript
const roads = [
  'A-B',
  'A-H',
  'A-P',
  'B-T',
  'D-E',
  'D-T',
  'E-G',
  'G-F',
  'G-S',
  'M-F',
  'M-P',
  'M-S',
  'M-T',
  'S-T',
];

function buildGraph(edges) {
  let graph = Object.create(null);
  function addEdge(from, to) {
    if (graph[from] == null) {
      graph[from] = [to];
    } else {
      graph[from].push(to);
    }
  }
  for (let [from, to] of edges.map((r) => r.split('-'))) {
    addEdge(from, to);
    addEdge(to, from);
  }
  return graph;
}

const roadGraph = buildGraph(roads);

console.log(roadGraph);

// {
//   A: ['B', 'H', 'P'],
//   B: ['A', 'T'],
//   H: ['A'],
//   P: ['A', 'M'],
//   T: ['B', 'D', 'M', 'S'],
//   D: ['E', 'T'],
//   E: ['D', 'G'],
//   G: ['E', 'F', 'S'],
//   F: ['G', 'M'],
//   S: ['G', 'M', 'T'],
//   M: ['F', 'P', 'S', 'T'],
// };
```

### 할 일

move 메서드에서 물건을 배달하고 next 상태에 반영한다. 하지만 초기 상태는 여전히 로봇이 우체국에 잇고 물건이 배달되지 않은 상황을 나타낸다.

```javascript
class VillageState {
  constructor(place, parcels) {
    this.place = place;
    this.parcels = parcels;
  }

  move(destination) {
    if (!roadGraph[this.place].includes(destination)) {
      // 현재 위치에서 목적지로 갈 수 없는 경우, 이전 상태를 반환
      return this;
    } else {
      // 현재 위치에서 목적지로 갈 수 있는 경우, 새로운 상태를 반환
      let parcels = this.parcels
        // map 메서드 호출로 물건의 이동을 처리
        .map((p) => {
          if (p.place !== this.place) return p;
          return { place: destination, address: p.address };
        })
        // filter 메서드 호출로 물건의 배달을 처리
        .filter((p) => p.place !== p.address);

      return new VillageState(destination, parcels);
    }
  }
}

let first = new VillageState('P', [{ place: 'P', address: 'A' }]);

let next = first.move('A');

console.log(next.place); // A
```

### 영구 데이터

자바스크립트에서는 거의 모든 것이 변경될 수 있으므로 지속적으로 유지되는 값을 사용하려면 어느 정도 제약이 따른다. Object.freeze라는 함수를 통해 객체의 속성에 쓰기가 불가능하도록 객체를 변경할 수 있다. 

### 시뮬레이션

배달 로봇이 계획을 세우고 실행할 수 있도록 기억을 전달하고 새로운 기억을 반환하도록 한다. 로봇이 반환할 것은 이동 방향과 다음에 호출될 때 반환되는 메모리 값을 모두 포함하는 객체다.

```javascript
function runRobot(state, robot, memory) {
  for (let turn = 0; ; turn++) {
    if (state.parcels.length === 0) {
      console.log(`Done in ${turn} turns`);
      break;
    }
    let action = robot(state, memory);
    state = state.move(action.direction);
    memory = action.memory;
    console.log(`Moved to ${action.direction}`);
  }
}

// 가장 단순한 전략은 로봇이 항상 임의의 방향으로 이동하는 것이다.
// 높은 확률로 결국 모든 물건과 만나게 되고, 어느 시점에는 배달해야 하는 장소에 도달하게 된다.
function randomPick(array) {
  let choice = Math.floor(Math.random() * array.length);
  return array[choice];
}

function randomRobot(state) {
  return { direction: randomPick(roadGraph[state.place]) };
}
```

어떤 물건도 같은 주소에서 발송되지 않아야 한다. 따라서 do 반복문에서는 같은 주소가 나오면 새로운 위치를 계속 선택한다.

```javascript
VillageState.random = function (parcelCount = 5) {
  let parcels = [];
  for (let i = 0; i < parcelCount; i++) {
    let address = randomPick(Object.keys(roadGraph));
    let place;
    do {
      place = randomPick(Object.keys(roadGraph));
    } while (place === address);
    parcels.push({ place, address });
  }
  return new VillageState('P', parcels);
};

runRobot(VillageState.random(), randomRobot);
// 미리 계획을 잘 세우지 못해서 물건 배달을 위해 로봇을 여러 번 돌려야 한다.
```

### 메일 트럭의 경로

경로 추적 로봇을 구현하려면 로봇 메모리를 사용한다. 로봇은 남은 경로를 메모리에 유지하고 매 실행마다 첫 번째 요소를 삭제한다.

### 길 찾기

그래프를 통해 경로를 찾는 문제는 일반적인 탐색 문제다. 여기서는 주어진 솔루션이 유효한지 알 수는 있지만 2더하기2와 같이 솔루션을 직접 계산할 수는 없다. 대신 적절한 솔루션을 찾을 때까지 잠재적인 솔루션을 계속 만들어야 한다.

그래프에서 가능한 경로의 수는 무한대다. 하지만 예제에서는 A부터 B까지의 경로를 탐색할 때 A에서 시작하는 경로만 필요하다. 또한 같은 장소를 두 번 방문하는 경로는 어떤 곳이든지 가장 효율적인 경로는 아니므로 신경 쓰지 않아도 된다. 따라서 경로 찾기에서 고려해야 할 경로의 수는 줄어든다.

최단 경로에 주로 관심이 있으므로 좋은 방법은 출발점에서부터 경로를 "확장"해서 목적지에 도달할 때까지 아직 방문하지 않은 도달 가능한 모든 장소를 탐색하는 것이다. 그렇게 하면 대상 경로를 탐색한 다음 다음 목적지까지 최단 경로를 찾아낸다.

```javascript
function findRoute(graph, from, to) {   
  
  // 작업 목록은 지나온 경로와 함께 다음에 탐색할 장소를 저장하는 배열이다.
  // 배열의 최초 값은 시작 위치와 빈 경로다.
  let work = [{ at: from, route: [] }];

  for (let i = 0; i < work.length; i++) {
    // 다음 항목을 가져온 후 탐색하면, 해당 위치에서 모든 도로를 볼 수 있다. 
    let { at, route } = work[i];

    // 탐색은 도달 가능한 경로를 먼저 탐색해야 한다.
    for (let place of graph[at]) {
      if (place === to) return route.concat(place);

      // 이미 살펴본 경로라면 그 장소로 가는 경로가 더 길거나 기존 경로와 정확히 같은 길이의 경로가 확인된 것이므로, 짧은 경로를 찾는 과정에서는 탐색할 필요가 없다.
      if (!work.some((w) => w.at === place)) {
        work.push({ at: place, route: route.concat(place) });
      }
    }
  }
}

console.log(findRoute(roadGraph, 'M', 'E'));
console.log(res); // ['B', 'T', 'D', 'E']
```

```javascript
function goalOrientedRobot({ place, parcels }, route) {
  if (route.length == 0) {
    let parcel = parcels[0];
    if (parcel.place != place) {
      route = findRoute(roadGraph, place, parcel.place);
    } else {
      route = findRoute(roadGraph, place, parcel.address);
    }
  }
  return { direction: route[0], memory: route.slice(1) };
}
```
이 로봇은 경로 추적 로봇과 마찬가지로 메모리 값을 이동할 방향의 목록으로 사용한다. 해당 목록이 비어 있다면 다음에 처리할 작업을 파악해야 한다. 물건 세트에서 배송되지 않은 첫 번째 물건을 가져온 다음, 해당 물건을 아직 수령하지 않은 경우 해당 물건 방향의 경로를 생성한다. 만약 물건을 수령했다면 물건을 배송해야 하므로 로봇은 배송 주소 방향의 경로를 생성한다.



