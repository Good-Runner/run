# 5장 고차함수

### 추상화 (abstraction)

프로그래밍의 맥락에서 추상화는 세부 사항을 숨기고 더 높은(또는 더 추상적인) 수준에서 문제를 다룰 수 있도록 해준다.

### 고차 함수 (Higher-Order Function)

다른 함수의 인수로 사용되거나 반환되는 함수를 고차 함수(HOF)라고 한다.<br/>
고차 함수를 사용하면 값뿐만 아니라 동작을 추상화할 수 있다.<br/>

고차 함수는 여러가지 모양이다.

#### 새로운 함수를 생성하는 함수
```tsx
function greaterThan(n) {
   return m => m > n;
}
let greatherThan10 = greaterThan(10);
console.log(greatherThan10(11)); // true
```

#### 다른 함수를 변경하는 함수
```tsx
function noisy(f) {
  return (...args) => {
    const result = f(...args);
    return result;
  }
}
noisy(Math.min)(3,2,1); // 1
```

#### 새로운 유형의 제어 흐름을 제공하는 함수
```tsx
function unless(test, then) {
  if (!test) then();
}

repeat(3, n => {
  unless(n % 2 == 1, () => {
    console.log(n, "is even");
  });
})
// 0 is even
// 2 is even
```

### 결합성

고차 함수는 연산의 구성이 필요할 때 빛을 발한다. 데이터 세트에서 사용되는 문자와 역사속으로 사라진 문자가 사용되기 시작한 연도의 평균을 찾는 코드 작성

```tsx
function average(array) {
  return array.reduce((a, b) => a + b) / array.length;
}

console.log(
  Math.round(average(
    SCRIPTS.filter(s => s.living).map(s => s.year)
  ))
) // 1165

console.log(
  Math.round(average(
    SCRIPTS.filter(s => !s.living).map(s => s.year)
  ))
) // 204
```
이 코드는 모든 문자 중에 사용하는 문자를 필터링하고 그 연도의 평균을 구하고 결과를 반올림하는 하나의 파이프라인으로 볼 수 있다.

이를 하나의 반복문으로 작성할 수도 있다.
```tsx
let total = 0, count = 0;
for (let script of SCRIPTS) {
  if (script.living) {
    total += script.year;
    count =+ 1;
  }
}
console.log(Math.round(total / count)); // 1165
```

하지만 이 코드는 무엇을 어떻게 계산하고 있는지 이해하기거 쉽지 않다.

컴퓨터 관점에서 두 가지 접근 방식은 상당한 차이가 있다. <br />
첫 번째는 filter와 map을 실행할 때 새 배열을 작성하는 반면, <br />
두 번째는 일부 숫자만 계산해서 더 적은 작업을 수행한다.

일반적으로는 가독성을 좋게 하는 접근 방법을 사용할 수 있지만, 아주 큰 배열을 처리하고 여러 번 반복하는 경우, 낮은 추상화로 추가적인 속도 개선 효과를 얻을 수 있다.

### 142p TODO
