# 5장 고차함수

### 추상화 (abstraction)

프로그래밍의 맥락에서 추상화는 세부 사항을 숨기고 더 높은(또는 더 추상적인) 수준에서 문제를 다룰 수 있도록 해준다.

### 고차 함수 (Higher-Order Function)

다른 함수의 인수로 사용되거나 반환되는 함수를 고차 함수(HOF)라고 한다.<br/>
고차 함수를 사용하면 값뿐만 아니라 동작을 추상화할 수 있다.<br/>

고차 함수는 여러가지 모양이다.

#### 새로운 함수를 생성하는 함수
```tsx
function greaterThan(n) {
   return m => m > n;
}
let greatherThan10 = greaterThan(10);
console.log(greatherThan10(11)); // true
```

#### 다른 함수를 변경하는 함수
```tsx
function noisy(f) {
  return (...args) => {
    const result = f(...args);
    return result;
  }
}
noisy(Math.min)(3,2,1); // 1
```

#### 새로운 유형의 제어 흐름을 제공하는 함수
```tsx
function unless(test, then) {
  if (!test) then();
}

repeat(3, n => {
  unless(n % 2 == 1, () => {
    console.log(n, "is even");
  });
})
// 0 is even
// 2 is even
```

### 결합성

고차 함수는 연산의 구성이 필요할 때 빛을 발한다. 데이터 세트에서 사용되는 문자와 역사속으로 사라진 문자가 사용되기 시작한 연도의 평균을 찾는 코드 작성

```tsx
function average(array) {
  return array.reduce((a, b) => a + b) / array.length;
}

console.log(
  Math.round(average(
    SCRIPTS.filter(s => s.living).map(s => s.year)
  ))
) // 1165

console.log(
  Math.round(average(
    SCRIPTS.filter(s => !s.living).map(s => s.year)
  ))
) // 204
```
이 코드는 모든 문자 중에 사용하는 문자를 필터링하고 그 연도의 평균을 구하고 결과를 반올림하는 하나의 파이프라인으로 볼 수 있다.

이를 하나의 반복문으로 작성할 수도 있다.
```tsx
let total = 0, count = 0;
for (let script of SCRIPTS) {
  if (script.living) {
    total += script.year;
    count =+ 1;
  }
}
console.log(Math.round(total / count)); // 1165
```

하지만 이 코드는 무엇을 어떻게 계산하고 있는지 이해하기거 쉽지 않다.

컴퓨터 관점에서 두 가지 접근 방식은 상당한 차이가 있다. <br />
첫 번째는 filter와 map을 실행할 때 새 배열을 작성하는 반면, <br />
두 번째는 일부 숫자만 계산해서 더 적은 작업을 수행한다.

일반적으로는 가독성을 좋게 하는 접근 방법을 사용할 수 있지만, 아주 큰 배열을 처리하고 여러 번 반복하는 경우, 낮은 추상화로 추가적인 속도 개선 효과를 얻을 수 있다.

### 문자열과 문자 코드

각 문자에는 연관된 문자 코드 범위 배열이 있다. 따라서 문자 코드가 주어지면 다음 함수를 사용해 해당 문자를 찾을 수 있다.

```tsx
function characterScript(code) {
    for (let script of SCRIPTS) {
        if (script.ranges.some(([from, to]) => {
            return code >= from && code < to;
        })) {
            return script;
        }
    }
    return null;
}

console.log(characterScript(121));
```

자바스크립트 문자열은 일련의 16비트 숫자로 인코딩된다. 이것을 코드 단위라고 한다. 
초기의 유니코드 문자 코드는 이 코드 단위에 맞도록 설계된다. 하지만 이것은 충분하지 않았고, 문자당 더 많은 메모리가 필요하게 되었고, 이를 해결하기 위해 UTF-16이 발명됐다. 이 코드 단위로 표현할 수 없는 문자는 두 개의 코드 단위(32비트)를 사용한다.<br/>

이모지가 사용되면서 모든 사람들이 두 개의 단위 문자를 사용하기 시작했다.<br/>
하지만 안타깝게도 length 속성을 통해 문자열의 길이를 얻어 오거나 대괄호를 사용해 내용에 접근하는 등의 자바스크립트 문자열에 관한 정확한 연산은 코드 단위로만 처리된다.<br/>

자바스크립트의 charCodeAt 메서드에서는 전체 문자 코드가 아닌 코드 단위를 제공한다.
나중에 추가된 codePointAt 메서드에서는 완전한 유니코드 문자를 제공한다. 이 메서드를 사용해 문자열에서 문자를 가져올 수 있다. 
하지만 codePointAt에 전달된 인수 역시 코드 단위 순서의 인덱스다. 따라서 문자열에 있는 모든 문자를 처리하려면 문자가 하나의 코드 단위를 차지하는지 또는 두 개의 코드 단위를 차지하는지 여부를 확인해야 한다.




