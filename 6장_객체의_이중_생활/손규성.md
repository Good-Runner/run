# 6장 객체의 이중 생활

## 1. 어떤 객체에 특정 속성이 있는지 확인하기 위해 in 연산자를 사용하는 것과 hasOwnProperty를 사용하는 것의 차이점은?

두 연산자의 차이점은 검사 범위에 있다. in 연산자는 객체 자신뿐 아니라, 프로토타입 체인 전체를 탐색하여 속성의 존재여부를 확인한다. 반면 hasOwnProperty는 객체 자신의 직접적인 속성만 검사한다.

```js
const profile = {
  name: "james",
  age: 23,
};

const job = Object.create(profile);
job.title = "developer";

console.log("name" in job); // -> true
console.log("title" in job); // -> true

console.log(job.hasOwnProperty("name")); // -> false
console.log(job.hasOwnProperty("title")); // -> true
```

따라서 상속된 속성, 라이브러리에서 추가된 속성이 의도치 않게 탐지되지 않도록 하려면 hasOwnProperty를 사용하는 것이 안전하다.

## 2. class 문법에서 super의 역할은?

상속 관계 중 상위 클래스를 수퍼클래스(superclass), 파생된 클래스를 서브클래스(subclass)라 칭한다. super는 서브클래스에서 수퍼클래스의 생성자나 메서드를 호출할 때 사용하는 문법적 도구이다.

```js
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log("I am going to start talking: ");
  }
}

class Dog extends Animal {
  constructor(name, breed) {
    super(name); // 부모 생성자 호출
    this.breed = breed;
  }

  speak() {
    super.speak(); // 부모 메서드 호출
    console.log(`${this.name} barks!`);
  }
}
```

## 3. Symbol.iterator은 무엇이고 자바스크립트에 도입된 이유는?

Symbol.iterator는 이터러블 프로토콜을 정의하는 특수한 Symbol 값이다. 객체가 for...of, 스프레드 연산자 등 반복 가능한 문법에 사용되려면, 객체 안에 Symbol.iterator 키로 정의된 메서드가 있어야 한다.

ES6에서 for...of, 스프레드 연산자, 구조 분해 등의 문법과 Map, Set 같은 자료구조가 대거 도입되었다. 이러한 기능들이 다양한 타입의 컬렉션에서 일관되게 동작하려면 통일된 이터레이션 프로토콜이 필요했고, 이를 위해 Symbol.iterator를 사용한다.

Symbol을 사용한 이유는 하위 호환성 때문이다. 만약 단순한 문자열 키 "iterator"를 썼다면, ES6 이전에 작성된 코드 중 iterator라는 속성을 이미 쓰고 있는 객체와 충돌할 위험이 있다. 심볼을 사용함으로서 키의 고유성을 확보여 기존 코드와 충돌 없이 안전하게 새로운 프로토콜을 도입할 수 있게 되었다.

```js
const cities = {
  data: ["Seoul", "Suwon", "Busan"],

  [Symbol.iterator]() {
    let i = 0;
    const data = this.data;

    return {
      next() {
        const isOver = i >= data.length;

        return {
          value: !isOver ? data[i++] : undefined,
          done: isOver,
        };
      },
    };
  },
};

for (const city of cities) {
  console.log(city); // -> Seoul Suwon Busan
}
```
