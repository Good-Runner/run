# 6장 객체의 이중 생활

## 내용

### 캡슐화

프로그램의 여러 영역은 인터페이스나 제한적인 함수 또는 정확한 구현을 숨기고 보다 추상적인 수준에서 ㅇ유용한 기능을 제공하는 바인딩을 통해 서로 상호작용한다. 

프로그램의 영역은 객체를 사용해서 모델링한다. 각 인터페이스는 특정 메서드와 속성으로 구성된다. 인터페이스의 일부분인 속성을 퍼블릭이라고 하며, 외부 코드에서 접근하지 못하는 나머지 속성을 프라이빗이라고 한다.

인터페이스와 구현은 분리하는 것이 좋다. 이 방법을 보통 캡슐화라고 한다.

### 메서드

메서드는 함수 값을 가지고 있는 속성이나 다름없다. 

### 📌 this 바인딩

함수가 메서드처럼 호출되면 함수 본문의 this 바인딩은 호출한 객체를 자동으로 가리킨다.

this는 다양한 방식으로 전달되는 추가적인 매개변수라고 생각할 수 있다. 함수가 호출되는 환경에 따라 this가 가리키는 대상이 달라진다.

자바스크립트에서 함수가 실행되면 실행 컨텍스트가 생성되고, 그 안에 this를 포함한 다양한 정보가 저장된다. <br />
이 this는 함수가 호출될 때 어떤 방식으로 호출되느냐에 따라 결정된다. 즉, 일반 함수는 호출 방식에 따라 this가 동적으로 결정된다.

**자바스크립트의 this 바인딩 규칙**
1. 기본 바인딩 (Default Binding)
   일반 함수를 호출하면 this는 전역 객체를 가리킵니다. (브라우저 환경은 window, Node.js 환경은 global, 엄격모드에서는 this가 undefined)
2. 암시적 바인딩 (Implicit Binding)
   객체의 메서드로 호출되면 this는 메서드를 호출한 객체를 가리킨다.
3. 명시적 바인딩 (Explicit Binding)
   call(), apply(), bind()을 사용하여 this를 지정할 수 있다.
4. new 바인딩 (Constructor Binding)
   생성자 함수 내부의 this는 생성자 함수가 미래에 생성할 인스턴스를 가리킨다. 

(+) 화살표 함수는 기존 함수와 다르게 자신만의 this 바인딩을 가지지 않으며, 화살표 함수가 선언된 위치의 상위 스코프에 있는 this를 그대로 사용한다.

### 프로토타입

프로토타입은 속성을 대체하는 용도로 사용되는 또 다른 객체다.
객체가 가지고 있지 않은 속성을 요청하면 객체의 프로토타입에서 해당 속성을 검색한 후, 해당 프로토타입의 프로토타입을 검색하고 계속해서 그다음 검색을 반복한다.

모든 객체의 조상 프로토타입으로 Object.prototype이 존재한다.

### 클래스

클래스의 인스턴스를 객체라고 한다. <br />
프로토타입은 메서드와 같이 클래스의 모든 인스턴스에서 동일한 값을 공유하기 위한 속성을 정의하는 데 사용한다.

#### 생성자 함수

함수 호출 부분의 앞에 new 키워드를 붙이면 그 함수는 생성자로 동작한다. 그렇게 하면 적절한 프로토타입을 갖는 객체가 자동으로 생성되고, 해당 함수의 this를 바인딩한 후, 해당 함수의 마지막에서 반환된다. 객체 생성에 사용되는 프로토타입 객체는 생성자 함수의 prototype 속성을 통해 확인할 수 있다.

```tsx
function Rabbit(type) {
   this.type = type;
}

Rabbit.prototype.speak = function(line) {
   console.log(`The ${this.type} rabbit says '${line}'`);
};

let weirdRabbit = new Rabbit("weird");

console.log(Object.getPrototypeOf(Rabbit) == Function.prototype); // true
console.log(Object.getPrototypeOf(weirdRabbit) == Rabbit.prototype); // true
```

생성자(사실상 모든 함수)는 자동으로 prototype 속성을 갖는다.
필요에 따라 이 객체를 새로운 객체로 덮어쓸 수 있다. 또는 기존 객체에 속성을 추가할 수도 있다.

프로토타입이 생성자와 연결되는 방식(prototype 속성을 통해)과 객체가 프로토타입(Object.getPrototypeOf)을 갖는 방식의 차이점을 이해해야 한다.
생성자는 함수이므로 생성자의 실제 프로토타입은 Function.prototype이다. 이 생성자의 prototype 속성에는 생성자를 통해 만들어진 인스턴스에서 사용하는 프로토타입이 포함된다.

#### 클래스 표기법

자바스크립트 클래스는 프로토타입 속성이 있는 생성자 함수다.

class 키워드는 클래스 선언의 시작이며 생성자와 일련의 메서드를 모두 한 곳에 정의할 수 있다.

### 파생 속성 재정의

객체에 속성을 추가하는 경우, 그 속성이 해당 프로토타입에 속성으로 존재하는지 여부와 관계없이 해당 객체에 속성이 추가된다.<br />
만약 프로토타입에 같은 이름의 속성이 이미 존재한다면 이 속성은 해당 객체가 소유한 속성에 가려져 더 이상 객체에 영향을 미치지 못한다.

프로토타입에 있는 속성을 재정의하는 것이 필요한 경우가 있다. <br />
재정의는 일반적인 클래스 객체의 인스턴스에 예외적인 속성을 표현해야 하는 경우 사용할 수 있으며, 예외적이지 않은 객체는 프로토타입의 표준 값을 사용할 수 있다.

재정의는 표준 함수와 배열 프로토타입에 기본 객체 프로토타입보다 더 다양한 toString 메서드를 제공하는 데에도 사용된다.

### 맵 자료구조

명사인 맵은 값(키)을 다른 값과 연결하는 자료 구조다. 

#### 자바스크립트의 객체 생성 방법
1. 객체 리터럴
    - 가장 일반적이고 간단한 방법
    - 객체 리터럴은 중괄호`{}` 내에 0개 이상의 프로퍼티를 정의한다.
    - 자바스크립트 엔진은 변수가 할당되는 시점에 객체 리터럴을 해석해 객체를 생성한다.

(객체 리터럴 방식 외의 객체 생성 방식은 모두 함수를 사용하여 객체를 생성)

2. Object 생성자 함수
3. 생성자 함수
4. Object.create 메서드
5. 클래스(ES6)

#### Map

예를 들어, 이름을 나이와 매핑하기 위해 객체 리터럴을 사용하고, 객체의 속성 이름은 사람의 이름이고 속성 값은 나이로 지정한다.
일반 객체는 Object.prototype에서 파생되므로 toString이 있는 것처럼 보인다.
따라서 일반 객체를 맵으로 사용하는 것은 위험하다. 이 문제를 회피하기 위해서는 Object.create에 null을 전달하여 Object.prototype에서 파생되지 않으며 않는 프로토타입이 없는 객체를 생성할 수 있다. 또한 자바스크립트의 Map을 사용할 수 있다. Map은 매핑을 저장하고 모든 유형의 키를 허용한다.

### 다형성

코드를 특정 인터페이스가 포함된 객체에서 함께 동작하도록 작성하면 해당 인터페이스를 지원하는 모든 객체에 해당 코드가 포함돼 동작하게 된다. 이러한 기법을 다형성이라고 한다. 다형성 코드는 해당 코드에서 사용하는 인터페이스가 지원되는 경우라면 다양한 형태의 값에서 동작할 수 있다.

### 심볼

여러 인터페이스에서 서로 다른 속성에 대해 동일한 속성 이름을 사용할 수 있다. 이런 경우 심볼을 사용한다.<br />
심볼은 Symbol 함수로 만든 값이다. 문자열과 달리 새롭게 생성된 심볼은 고유하며 동일한 심볼을 두 번 만들 수 없다.<br />
Symbol에 전달하는 문자열은 이 심볼을 문자열로 변환하는 시점에 포함되며, 심볼이 콘솔에 출력되는 경우가 있다면 해당 시점에 이 문자열을 보다 쉽게 확인할 수 있다. 그리고 여러 심볼은 동일한 이름을 사용할 수 있다. 

심볼은 속성 이름으로 사용할 수 있고 고유하기 때문에, 어떤 이름을 사용하더라도 다른 속성과 충돌하지 않는 인터페이스를 정의할 수 있다.
속성 이름 주위에 대괄호를 사용해서 객체 표현식과 클래스에 심볼 속성을 포함시킬 수 있다. 이렇게 하면 해당 심볼이 포함된 바인딩을 참조할 수 있다.

```javascript
const toStringSymbol = Symbol("toString");
Array.prototype[toStringSymbol] = function() {
    return `${this.length} cm of blue yarn`;
}

console.log([1, 2].toString()); // 1,2
console.log([1, 2][toStringSymbol]()); // 2 cm of blue yarn
```

### 반복자 인터페이스

for/of 반복문에 전달된 객체는 반복(iteratiion)해 처리할 수 있어야 한다. 즉 해당 객체에는 Symbol.iterator 심볼을 사용해서 명명된 메서드가 존재함을 의미한다.

해당 메서드가 호출되면 두 번째 인터페이스인 iterator를 제공하는 객체가 반환되고, 이 객체가 실제로 반복된다. 이 객체의 `next` 메서드에서는 다음 결과를 반환한다. 이 결과에는 `value` 속성과 `done` 속성이 포함되며, `value` 속성은 다음 값을 제공하고, `done` 속성은 더 이상 결과가 없으면 `true`를, 그렇지 않으면 `false`를 제공한다.

| TODO:162P 예제

### 게터, 세터, 스태틱

인터페이스는 대부분 메서드로 구성되는 것이 일반적이지만, 비기능적 값인 속성을 포함할 수 있다. 
예를 들어, Map 객체에는 몇 개의 키가 저장돼 있는지 알려주는 size 속성이 있다. 

이 객체의 인스턴스에 있는 size와 같은 속성은 직접 계산하고 저장하지 않아도 된다.
직접 접근되는 속성조차도 메서드 호출로 숨길 수 있다. 이 같은 메서드를 getter(게터)라고 하며 객체 표현식이나 클래스 선언에서 메서드 이름 앞에 get을 붙여 정의한다. 속성에 기록하는 경우 setter(세터)를 사용한다.

```javascript
let varyingSize = {
    get size() {
        return Math.floor(Math.random() * 100);
    }
};

console.log(varyingSize.size) // 94
```

```javascript
class Temperature {
    constructor(celsius) {
        this.celsius = celsius;
    }
    get fahrenhit() {
        return this.celsius * 1.8 + 32;
    }
    set fahrenheit(value) {
        return this.celsius = (value - 32) / 1.8;
    }
    static fromFahrenheit(value) {
        return new Temperature((value - 32) / 1.8);
    }
}

let temp = new Temperature(22);
console.log(temp.fahrenhit); // 71.6

console.log(Temperature.fromFahrenheit(100).celsius); // 37.77777777777778
```
필요에 따라 프로토타입이 아닌 생성자 함수에 일부 속성을 직접 추가할 수도 있다. 이렇게 추가된 메서드는 클래스 인스턴스에 접근할 수는 없지만, 인스턴스를 생성하는 부가적인 방법으로 제공될 수 있다.

클래스 선언에서 이름 앞에 static 키워드가 붙어 있는 메서드는 생성자에 포함된다.

### 상속

자바스크립트의 프로토타입 체계를 사용하면, 기존 클래스와 비슷하지만 일부 속성은 새롭게 정의해 새로운 클래스를 만들 수 있다. 새 클래스의 프로토타입은 이전 프로토타입에서 파생되지만 set 메서드에 대한 새로운 정의가 추가된다. 객체지향 프로그래밍 용어로 표현하면 이것을 상속이라고 한다. 새 클래스는 이전 클래스의 속성과 동작을 상속한다. extends라는 단어를 사용한다는 것은 이 클래스가 기본 object 프로토타입 기반이 아니고 다른 클래스 기반이라는 것을 나타낸다. 이 클래스를 수퍼 클래스라고 하고, 파생된 클래스는 하위 클래스라고 한다.

상속은 비교적 적은 작업량으로 기존 데이터 유형과 조금 다른 데이터 유형을 구축할 수 있다. 캡슐화, 다형성과 함께 객체지향의 기본적인 특징이다. 

#### 캡슐화와 다형성

캡슐화와 다형성은 코드 조각을 서로 분리해 전체적으로 프로그램의 엉킴을 줄여주지만 상속은 기본적으로 클래스를 한데 묶어주므로 더 엉키게 만든다. 클래스에서 상속하는 경우는 일반적인 방식으로 클래스를 사용할 때보다 동작 방식을 더 자세히 알아야 한다. 상속은 유용한 도구이므로 때에 따라 프로그램에서 종종 사용할 수 있지만, 상속이 사용하려는 첫 번째 도구가 돼서는 안 되며, 클래스 계층 구조를 만들 기회를 적극적으로 찾아서도 안 된다.

### instanceof 연산자

객체가 어떤 클래스에서 파생됐는지 여부를 확인할 필요가 있는 경우 instanceof라는 이항 연산자를 제공하며 이를 확인할 수 있다.

이 연산자는 상속받은 유형을 통해 확인하며, Array와 같은 표준 생성자에도 적용할 수 있다. 대부분의 객체는 Object의 인스턴스다.

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
}
class Rabbit extends Animal {
}

const rabbit1 = new Rabbit('r1');

console.log(rabbit1 instanceof Rabbit) // true
console.log(rabbit1 instanceof Object) // true
```

## Quiz

### 1. 자바스크립트의 this 바인딩이 어떻게 이루어지는지, 화살표 함수는 어떤 특징을 가지는지 설명

자바스크립트에서 this는 함수가 호출되는 방식(실행 컨텍스트)에 따라 동적으로 결정된다.

일반 함수로 호출될 때, this는 기본적으로 전역 객체(window 또는 global)를 가리킨다. 다만, 엄격 모드('use strict')에서는 this가 undefined가 된다.

객체의 속성으로 함수가 정의되고 메서드처럼 호출될 때, this는 해당 메서드를 호출한 객체를 가리킨다.

화살표 함수는 기존 함수와 다르게 자신만의 this 바인딩을 생성하지 않는다. 대신, 화살표 함수가 선언된 위치의 상위 스코프(lexical scope)에 있는 this를 그대로 상속받아 사용한다. 

### 2. 자바스크립트에서 프로토타입(Prototype)은 무엇이며, 클래스와의 관계 속에서 어떤 역할을 하는지 설명

**프로토타입(Prototype)**은 자바스크립트 객체가 상속을 구현하기 위해 사용하는 프로토타입 객체이다. 객체에 속성이 없을 때, 자바스크립트는 이 프로토타입 객체를 따라 상위 객체로 검색을 진행하며 프로토타입 체인을 형성한다. 클래스(ES6 class) 관점에서, 프로토타입은 모든 인스턴스가 메서드와 속성을 공유하도록 정의하는 메커니즘이다. class 내부에 정의된 메서드는 생성자 함수의 prototype 속성에 연결된다.


### 3. Map 자료구조가 일반 객체 리터럴을 맵처럼 사용하는 것보다 안전하고 권장되는 이유

Map 자료구조는 일반 객체 리터럴을 맵처럼 사용하는 것보다 안전하고 권장되는 방식이다. 일반 객체는 **Object.prototype**에서 파생되어 toString 같은 기본 속성 이름과 키가 충돌할 위험이 있다. 하지만 Map은 프로토타입 체인에서 자유로워 충돌 위험이 없으며, 문자열 외에 모든 데이터 타입을 키로 허용한다. 또한, size 속성 및 반복자 지원 등 매핑 관리를 위한 내장 기능을 제공한다.

### 4. 다형성에 대해 설명

다형성은 하나의 코드가 다양한 형태의 값에서 동작할 수 있도록 하는 객체 지향 원칙이다. 이는 코드를 특정 객체 타입이 아닌 **공통 인터페이스(메서드 집합)**를 기반으로 작성함으로써 구현된다. 특정 인터페이스를 지원하는 객체라면, 해당 코드는 객체의 구체적인 타입에 관계없이 동작할 수 있다. 이러한 특성은 코드의 유연성과 확장성을 높이고, 모듈 간의 결합도를 낮춘다.

### 5. 자바스크립트에서 **'심볼(Symbol)'**을 사용하는 주된 목적은 무엇이며, 속성 이름으로 사용할 때의 이점을 설명

자바스크립트에서 **심볼(Symbol)**을 사용하는 주된 목적은 속성 이름 간의 충돌을 방지하는 것이다. 심볼은 Symbol() 함수로 생성되며, 생성될 때마다 고유성이 보장된다. 속성 이름으로 심볼을 사용하면, 다른 속성과 이름이 중복되지 않는 고유한 인터페이스를 안전하게 정의할 수 있다. 또한, 심볼 속성은 일반적으로 열거되지 않아 객체의 내부 구현 요소를 은닉하는 데 유용하다.

### 6. 자바스크립트의 반복자(Iterator) 인터페이스에 대해 설명하고, 이것이 for...of 반복문과 어떤 관계가 있는지 설명

반복자(Iterator) 인터페이스는 객체가 for...of 반복문과 같은 반복 구조에서 순회될 수 있도록 하는 규약이다. 객체는 Symbol.iterator 심볼을 이름으로 하는 메서드를 구현해야 하며, 이 메서드는 next() 메서드를 가진 Iterator 객체를 반환한다. next()는 호출될 때마다 { value: 값, done: Boolean } 형태의 결과 객체를 반환한다. for...of 반복문은 이 인터페이스를 활용하여, 객체의 Symbol.iterator를 호출하고 반환된 Iterator의 next()를 반복적으로 호출하며 요소들을 순회한다.
