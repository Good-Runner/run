# 6장 객체의 이중 생활

### 캡슐화

프로그램의 여러 영역은 인터페이스나 제한적인 함수 또는 정확한 구현을 숨기고 보다 추상적인 수준에서 ㅇ유용한 기능을 제공하는 바인딩을 통해 서로 상호작용한다. 

프로그램의 영역은 객체를 사용해서 모델링한다. 각 인터페이스는 특정 메서드와 속성으로 구성된다. 인터페이스의 일부분인 속성을 퍼블릭이라고 하며, 외부 코드에서 접근하지 못하는 나머지 속성을 프라이빗이라고 한다.

인터페이스와 구현은 분리하는 것이 좋다. 이 방법을 보통 캡슐화라고 한다.

### 메서드

메서드는 함수 값을 가지고 있는 속성이나 다름없다. 

### 📌 this 바인딩

함수가 메서드처럼 호출되면 함수 본문의 this 바인딩은 호출한 객체를 자동으로 가리킨다.

this는 다양한 방식으로 전달되는 추가적인 매개변수라고 생각할 수 있다. 함수가 호출되는 환경에 따라 this가 가리키는 대상이 달라진다.

자바스크립트에서 함수가 실행되면 실행 컨텍스트가 생성되고, 그 안에 this를 포함한 다양한 정보가 저장된다. <br />
이 this는 함수가 호출될 때 어떤 방식으로 호출되느냐에 따라 결정된다. 즉, 일반 함수는 호출 방식에 따라 this가 동적으로 결정된다.

**자바스크립트의 this 바인딩 규칙**
1. 기본 바인딩 (Default Binding)
   일반 함수를 호출하면 this는 전역 객체를 가리킵니다. (브라우저 환경은 window, Node.js 환경은 global, 엄격모드에서는 this가 undefined)
2. 암시적 바인딩 (Implicit Binding)
   객체의 메서드로 호출되면 this는 메서드를 호출한 객체를 가리킨다.
3. 명시적 바인딩 (Explicit Binding)
   call(), apply(), bind()을 사용하여 this를 지정할 수 있다.
4. new 바인딩 (Constructor Binding)
   생성자 함수 내부의 this는 생성자 함수가 미래에 생성할 인스턴스를 가리킨다. 

(+) 화살표 함수는 기존 함수와 다르게 자신만의 this 바인딩을 가지지 않으며, 화살표 함수가 선언된 위치의 상위 스코프에 있는 this를 그대로 사용한다.

### 프로토타입

프로토타입은 속성을 대체하는 용도로 사용되는 또 다른 객체다.
객체가 가지고 있지 않은 속성을 요청하면 객체의 프로토타입에서 해당 속성을 검색한 후, 해당 프로토타입의 프로토타입을 검색하고 계속해서 그다음 검색을 반복한다.

모든 객체의 조상 프로토타입으로 Object.prototype이 존재한다.

### 클래스

클래스의 인스턴스를 객체라고 한다. <br />
프로토타입은 메서드와 같이 클래스의 모든 인스턴스에서 동일한 값을 공유하기 위한 속성을 정의하는 데 사용한다.

#### 생성자 함수

함수 호출 부분의 앞에 new 키워드를 붙이면 그 함수는 생성자로 동작한다. 그렇게 하면 적절한 프로토타입을 갖는 객체가 자동으로 생성되고, 해당 함수의 this를 바인딩한 후, 해당 함수의 마지막에서 반환된다. 객체 생성에 사용되는 프로토타입 객체는 생성자 함수의 prototype 속성을 통해 확인할 수 있다.

```tsx
function Rabbit(type) {
   this.type = type;
}

Rabbit.prototype.speak = function(line) {
   console.log(`The ${this.type} rabbit says '${line}'`);
};

let weirdRabbit = new Rabbit("weird");

console.log(Object.getPrototypeOf(Rabbit) == Function.prototype); // true
console.log(Object.getPrototypeOf(weirdRabbit) == Rabbit.prototype); // true
```

생성자(사실상 모든 함수)는 자동으로 prototype 속성을 갖는다.
필요에 따라 이 객체를 새로운 객체로 덮어쓸 수 있다. 또는 기존 객체에 속성을 추가할 수도 있다.

프로토타입이 생성자와 연결되는 방식(prototype 속성을 통해)과 객체가 프로토타입(Object.getPrototypeOf)을 갖는 방식의 차이점을 이해해야 한다.
생성자는 함수이므로 생성자의 실제 프로토타입은 Function.prototype이다. 이 생성자의 prototype 속성에는 생성자를 통해 만들어진 인스턴스에서 사용하는 프로토타입이 포함된다.

#### 클래스 표기법

자바스크립트 클래스는 프로토타입 속성이 있는 생성자 함수다.

class 키워드는 클래스 선언의 시작이며 생성자와 일련의 메서드를 모두 한 곳에 정의할 수 있다.

### 파생 속성 재정의

객체에 속성을 추가하는 경우, 그 속성이 해당 프로토타입에 속성으로 존재하는지 여부와 관계없이 해당 객체에 속성이 추가된다.<br />
만약 프로토타입에 같은 이름의 속성이 이미 존재한다면 이 속성은 해당 객체가 소유한 속성에 가려져 더 이상 객체에 영향을 미치지 못한다.

프로토타입에 있는 속성을 재정의하는 것이 필요한 경우가 있다. <br />
재정의는 일반적인 클래스 객체의 인스턴스에 예외적인 속성을 표현해야 하는 경우 사용할 수 있으며, 예외적이지 않은 객체는 프로토타입의 표준 값을 사용할 수 있다.

재정의는 표준 함수와 배열 프로토타입에 기본 객체 프로토타입보다 더 다양한 toString 메서드를 제공하는 데에도 사용된다.

### 맵 자료구조

명사인 맵은 값(키)을 다른 값과 연결하는 자료 구조다. 

#### 자바스크립트의 객체 생성 방법
1. 객체 리터럴
    - 가장 일반적이고 간단한 방법
    - 객체 리터럴은 중괄호`{}` 내에 0개 이상의 프로퍼티를 정의한다.
    - 자바스크립트 엔진은 변수가 할당되는 시점에 객체 리터럴을 해석해 객체를 생성한다.

(객체 리터럴 방식 외의 객체 생성 방식은 모두 함수를 사용하여 객체를 생성)

2. Object 생성자 함수
3. 생성자 함수
4. Object.create 메서드
5. 클래스(ES6)

#### Map

예를 들어, 이름을 나이와 매핑하기 위해 객체 리터럴을 사용하고, 객체의 속성 이름은 사람의 이름이고 속성 값은 나이로 지정한다.
일반 객체는 Object.prototype에서 파생되므로 toString이 있는 것처럼 보인다.
따라서 일반 객체를 맵으로 사용하는 것은 위험하다. 이 문제를 회피하기 위해서는 Object.create에 null을 전달하여 Object.prototype에서 파생되지 않으며 않는 프로토타입이 없는 객체를 생성할 수 있다. 또한 자바스크립트의 Map을 사용할 수 있다. Map은 매핑을 저장하고 모든 유형의 키를 허용한다.

### 다형성

코드를 특정 인터페이스가 포함된 객체에서 함께 동작하도록 작성하면 해당 인터페이스를 지원하는 모든 객체에 해당 코드가 포함돼 동작하게 된다. 이러한 기법을 다형성이라고 한다. 다형성 코드는 해당 코드에서 사용하는 인터페이스가 지원되는 경우라면 다양한 형태의 값에서 동작할 수 있다.

### 심볼

여러 인터페이스에서 서로 다른 속성에 대해 동일한 속성 이름을 사용할 수 있다. 이런 경우 심볼을 사용한다.<br />
심볼은 Symbol 함수로 만든 값이다. 문자열과 달리 새롭게 생성된 심볼은 고유하며 동일한 심볼을 두 번 만들 수 없다.<br />
Symbol에 전달하는 문자열은 이 심볼을 문자열로 변환하는 시점에 포함되며, 심볼이 콘솔에 출력되는 경우가 있다면 해당 시점에 이 문자열을 보다 쉽게 확인할 수 있다. 그리고 여러 심볼은 동일한 이름을 사용할 수 있다. 

심볼은 속성 이름으로 사용할 수 있고 고유하기 때문에, 어떤 이름을 사용하더라도 다른 속성과 충돌하지 않는 인터페이스를 정의할 수 있다.
속성 이름 주위에 대괄호를 사용해서 객체 표현식과 클래스에 심볼 속성을 포함시킬 수 있다. 이렇게 하면 해당 심볼이 포함된 바인딩을 참조할 수 있다.

```javascript
const toStringSymbol = Symbol("toString");
Array.prototype[toStringSymbol] = function() {
    return `${this.length} cm of blue yarn`;
}

console.log([1, 2].toString()); // 1,2
console.log([1, 2][toStringSymbol]()); // 2 cm of blue yarn
```

### 반복자 인터페이스

for/of 반복문에 전달된 객체는 반복(iteratiion)해 처리할 수 있어야 한다. 즉 해당 객체에는 Symbol.iterator 심볼을 사용해서 명명된 메서드가 존재함을 의미한다.

해당 메서드가 호출되면 두 번째 인터페이스인 iterator를 제공하는 객체가 반환되고, 이 객체가 실제로 반복된다. 이 객체의 `next` 메서드에서는 다음 결과를 반환한다. 이 결과에는 `value` 속성과 `done` 속성이 포함되며, `value` 속성은 다음 값을 제공하고, `done` 속성은 더 이상 결과가 없으면 `true`를, 그렇지 않으면 `false`를 제공한다.

TODO:162P 예제

### 게터, 세터, 스태틱

### 상속

### instanceof 연산자
