# 6장 객체의 이중 생활

## 1. 프로토타입 생성/결정 시점과 상속 연결은 어떻게 이뤄지나요?

프로토타입은 생성자 함수와 함께 만들어집니다. 함수가 정의될 때 자동으로 prototype 객체가 생기고, 자바스크립트 엔진이 실행을 시작하면서 전역 객체를 만들 때는 빌트인 생성자 함수들과 그에 연결된 프로토타입들도 미리 준비됩니다.

이후에 인스턴스를 생성하면 내부적으로 [[Prototype]]이 생성자의 prototype과 연결되어 상속이 이뤄집니다. 객체 리터럴로 만든 객체라면 별도의 생성자가 없으므로 기본적으로 Object.prototype을 프로토타입으로 가지게 됩니다.

결국 모든 프로토타입 체인의 끝은 Object.prototype이고, 최종적으로는 null을 가리키면서 종료됩니다.

<br />

## 2. 맵 자료구조를 일반 객체가 아닌 Map 객체를 사용하면 얻을 수 있는 이점이 무엇인가요?

Map 객체는 일반 객체와 달리 key로 문자열뿐만 아니라 객체, 함수 등 모든 값을 사용할 수 있어 더 유연합니다. 또한 삽입 순서를 기억하기 때문에 순회 시 일관된 순서를 보장합니다.

size 프로퍼티를 통해 원소 개수를 바로 확인할 수 있어 Object.keys(obj).length 같은 번거로운 작업이 필요 없습니다. 또한 성능 측면에서도 빈번한 추가, 삭제 작업에서 일반 객체보다 효율적인 경우가 많습니다. (set, get, has) 마지막으로 프로토타입 체인 오염 위험이 없으므로 예외 상황을 피할 수 있습니다.

<br />

## 3. 일반 함수, 메서드, 화살표 함수에서 this는 각각 어떻게 동작하나요?

일반 함수로 호출된 경우(중첩 함수, 콜백 포함)에는 기본적으로 this가 전역 객체에 바인딩되며, strict mode에서는 전역 객체 대신 undefined가 됩니다.

메서드 내부의 this는 메서드를 호출한 객체에 바인딩되므로, 같은 함수라도 호출 방식에 따라 this 값이 달라지는 것이 핵심입니다.

한편, 화살표 함수는 자체적인 this 바인딩을 가지지 않고 정의된 위치의 상위 스코프의 this를 그대로 사용합니다. 이 특징 덕분에 콜백이나 중첩 함수에서 외부의 this를 유지하기 위해 bind 대신 화살표 함수를 자주 활용합니다.

```js
// 1. 일반 함수
function normalFunc() {
  console.log(this);
}
normalFunc(); 
// 브라우저 : window or undefined (strict)


// 2. 메서드
const obj1 = {
  name: 'dk',
  method() {
    console.log(this.name);
  },
};
obj1.method(); // 'dk' (메서드를 호출한 객체 obj1이 this)

// 3. 메서드 내부 일반 함수
const obj2 = {
  value: 100,
  method() {
    console.log("method this:", this.value); // 100

    function innerFunc() {
      console.log("innerFunc this:", this);
    }
    innerFunc(); 
    // 브라우저 : window or undefined (strict)
  },
};
obj2.method();

// 4. 화살표 함수
const obj3 = {
  name: 'dk',
  method() {
    const arrow = () => console.log(this.name);
    arrow();
  },
};
obj3.method(); // 'dk' (화살표 함수는 상위 스코프 this(obj3)를 사용)
```

<br />

## 4. 심벌(Symbol)을 프로퍼티 키로 쓰면 어떤 장점이 있나요?

심벌은 유일무이한 값이기 때문에, 객체의 프로퍼티 키로 사용하면 절대 다른 키와 충돌하지 않습니다. 문자열 키와 달리 미래에 같은 이름의 키가 추가되어도 안전하며, for...in이나 Object.keys로 열거되지 않아 은닉성도 확보할 수 있습니다. 따라서 상수 정의, 외부에 노출할 필요 없는 내부용 프로퍼티, 혹은 표준 빌트인 객체 확장 같은 상황에서 심벌 키를 쓰면 안전성과 유지보수성이 크게 올라갑니다.

<br />

## 5. 일반 객체와 이터러블(iterable)의 차이는 무엇인가요?

일반 객체는 단순히 key value 쌍을 가진 구조라서 for...in으로 순회할 수 있지만, for...of나 스프레드 문법에는 사용할 수 없습니다. 반대로 이터러블은 Symbol.iterator 메서드를 구현하여 이터레이터를 반환할 수 있는 객체로, for...of, 스프레드, 디스트럭처링 할당 등과 함께 동작합니다. 예를 들어 배열, 문자열, Map, Set은 모두 빌트인 이터러블이므로 일관된 방식으로 순회가 가능합니다. 즉, 이터러블은 데이터를 “공급자”로 제공하는 표준 인터페이스를 따른다는 점에서 일반 객체와 구분됩니다.


<br />

## 4.객체에 hasOwnProperty란 속성이 포함되야 하는경우는 어떻게 해야할까? 객체의 자체 속성이 메서드 값을 숨기기 때문에 더 이상 해당 메서드를 호출할 수 없다 해당 이름의 속성을 가진 객체에서 hasOwnProperty를 호출하려면 어떤방법을 사용해야하는가?

객체에 hasOwnProperty라는 이름의 속성이 직접 정의되어 있으면, 원래 Object.prototype에 있던 메서드가 가려져서 더 이상 obj.hasOwnProperty(key)처럼 직접 호출할 수 없습니다. 이 문제를 해결하기 위해서는 프로토타입 체인 상에 있는 원래 메서드를 명시적으로 꺼내 써야 합니다.

가장 보편적인 방식은 Object.prototype.hasOwnProperty.call(obj, key)를 사용하는 것으로, 이렇게 하면 객체의 자체 속성이 hasOwnProperty를 덮어썼더라도 안전하게 해당 키가 자체 속성인지 확인할 수 있습니다.

최신 자바스크립트(ES2022)에서는 Object.hasOwn(obj, key)라는 더 간결한 표준 메서드가 추가되어, 프로토타입 체인을 직접 건드리지 않고 동일한 결과를 얻을 수 있습니다. 따라서 구형 환경까지 고려한다면 Object.prototype.hasOwnProperty.call 방식을 쓰는 것이 안전하고, Node 18 이상이나 최신 브라우저 환경이라면 Object.hasOwn을 사용하는 것이 더 깔끔합니다.

```js
console.log(Object.prototype.hasOwnProperty.call(obj, "foo"));
console.log(Object.hasOwn(obj, "foo"));
```
