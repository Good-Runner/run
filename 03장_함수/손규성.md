# 3장 함수

## 1. fn1 안에 fn2가 중첩되어 있다. 이때 fn2는 fn1의 변수를 참조할 수 있지만, fn1은 fn2의 변수를 참조할 수 없는 이유를 설명하시오.

자바스크립트에서 바인딩의 가시성은 렉시컬 스코프 규칙을 따르기 때문에 함수가 호출된 위치가 아닌, 선언된 위치에 따라 상위 스코프가 결정됩니다. 때문에 fn2은 본인이 정의된 fn1의 스코프를 상위 스코프로 인식하며, fn1 지역 변수에 접근할 수 있게 됩니다.

```js
const global = 100;

const fn1 = () => {
  let outer = 10;

  const fn2 = () => {
    console.log(global + outer); // -> 110, fn1 변수 참조 가능
  };

  fn2();
};
```

fn2가 변수를 참조할 때, JS 엔진은 스코프 체인을 따라 자기 스코프 → 상위 스코프 (fn1) → 전역 스코프 순으로 검색합니다

## 2. fn1 함수 실행 중 fn2 함수가 실행되었다. fn2 함수가 종료된 후 fn1 함수로 돌아가야 하는데, 자바스크립트 엔진은 fn1 함수로 돌아가야 한다는 사실을 어떻게 알고 있는가?

자바스크립트 엔진은 호출 스택을 사용하여 함수 실행 순서를 관리합니다. 함수가 호출되면 실행 컨텍스트가 스택에 추가되고, 함수가 종료되면 실행 컨텍스트가 제거됩니다.

```js
const fn1 = () => {
  console.log("fn1 ran");
  fn2();
};

const fn2 = () => {
  console.log("fn2 ran");
};

fn1();
```

fn1 함수 실행 중 fn2 함수가 실행되는 경우 호출 스택의 흐름은 다음과 같습니다.

1. fn1 함수 실행 (실행 컨텍스트 추가)
2. fn2 함수 실행 (실행 컨텍스트 추가)
3. fn2 함수 종료 (실행 컨텍스트 제거)
4. fn1 실행 컨텍스트 확인
5. fn1 함수 종료 (실행 컨텍스트 제거)

스택 자료구조의 LIFO 특성으로 인해 자바스크립트 엔진은 한 개의 실행 컨텍스트를 제거할 때마다 다음에 실행해야 할 실행 컨텍스트가 무엇인지 알 수 있는 구조입니다.

## 3. 순수 함수에 대해 설명해 주세요.

순수 함수란 부수 효과가 없고, 외부 상태에 의존하지 않으며, 같은 입력값에 대해 항상 같은 출력을 반환하는 함수입니다. 이 때문에 결과가 예측 가능하고, 테스트와 디버깅이 쉽다는 장점이 있습니다.

```js
const subtract = (x, y) => {
  return x - y;
};
```

## 4. 클로저에 대해 설명해 주세요.

클로저는 함수가 선언될 때의 스코프를 기억하는 함수입니다. 즉, 본인의 상위 스코프에 있는 변수에 계속 접근할 수 있는 함수라고 할 수 있습니다. 클로저가 가장 유용하게 사용되는 상황은 데이터 은닉이 필요할 때입니다.

```js
const getCounter = () => {
  let count = 0; // count값 은닉, 외부에서 직접 접근 불가

  return {
    increase: () => {
      count += 1;
    },
    decrease: () => {
      count -= 1;
    },
  };
};

const counter = getCounter();

console.log(counter.increase()); // -> 1
console.log(counter.increase()); // -> 2
console.log(counter.decrease()); // -> 1
```

getCounter 함수가 종료되면 지역 변수였던 count는 원래 스코프에서 벗어나 사라져야 합니다. 하지만 increase와 decrease 함수가 클로저로서 count를 참조하고 있기 때문에, 자바스크립트 엔진은 해당 변수를 메모리에서 해제하지 않고 유지합니다. 이 덕분에 외부에서도 간접적으로 count 값을 읽고 변경할 수 있게 됩니다.
