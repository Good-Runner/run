# 4장 객체와 배열 자료 구조

## 1. delete 연산자와 속성을 undefined로 설정하는 것의 차이점은 무엇인가?

delete 연산자를 사용하면 객체에서 해당 속성 자체가 제거된다. 따라서 in 연산자로 확인했을 때 false가 반환되고, Object.keys 메서드로 확인해도 해당 키는 보이지 않는다.

```js
const user = {
  name: "james",
  age: 22,
  job: "developer",
};

delete user.name;

console.log(Object.keys(user)); // -> ['age', 'job']
console.log("name" in user); // -> false
```

반대로 속성을 undefined로 직접 할당하면 속성은 그대로 남아 있고, 단지 값만 undefined로 변경된다. 이 경우 in 연산자는 true를 반환하고, Object.keys에서도 해당 키가 계속 보인다.

```js
const user = {
  name: "alex",
  age: 25,
  job: "doctor",
};

user.name = undefined;

console.log(Object.keys(user)); // -> ['name', 'age', 'job']
console.log("name" in user); // -> true
```

## 2. 데이터를 전송할 때 그냥 객체를 사용하지 않고 JSON을 사용하는 이유는?

자바스크립트의 객체는 런타임 환경에서만 유효한 메모리 참조 기반 구조이다. 각 속성은 "키" → (메모리 주소) → 값 형태로 저장되며, 이 구조는 자바스크립트 엔진 내부에서만 의미를 가진다.

```js
const user = {
  name: "alex",
  age: 25,
};
```

위 객체의 경우 아래와 같이 관리된다고 볼 수 있다.

- name > 주소(0x01) > 'alex'
- age > 주소(0x02) > 25

하지만 이 참조 구조는 메모리 내부에서만 유효하기 때문에, 네트워크를 통해 다른 시스템으로 전송하거나 디스크에 저장할 수 없다.

JSON.stringify를 사용하면 이 메모리 참조 기반 객체가 언어와 환경에 독립적인 문자열 데이터로 변환된다. 즉, 객체의 런타임 구조를 직렬화하여 모든 속성을 덤프한 문자열 데이터로 반환된다. JSON은 단순 문자열이므로 파일에 저장할 수 있고, 네트워크를 통해 전송할 수 있으며, 다른 언어와 환경에서도 읽고 해석할 수 있다.
